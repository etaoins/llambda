#ifndef _LLIBY_BINDING_ANYCELL_H
#define _LLIBY_BINDING_ANYCELL_H

#include <cstddef>
#include <cassert>

#include "alloc/GarbageState.h"
#include "alloc/allocator.h"

#include "generated/declaretypes.h"
#include "generated/CellTypeId.h"

namespace lliby
{

class AnyCell
{
#include "generated/AnyCellMembers.h"
public:
	void *operator new(size_t s, void *placement)
	{
		return placement;
	}

	// Don't allow heap allocations
	void *operator new(size_t s) = delete;

	void operator delete(void *value)
	{
		// Since exceptions are enabled the compiler will wants to implicitly call delete in some unwind paths. This
		// isn't actually harmful as we'll eventually garbage collect the cell.
	}

	/**
	 * Returns if this cell is a global constant
	 *
	 * Constants are generated by codegen where allowed by R7RS and may be placed in rodata. Attempting to modify them
	 * will result in undefined behaviour (typically a SIGBUS)
	 */
	bool isGlobalConstant() const
	{
		return m_gcState == GarbageState::GlobalConstant;
	}

	/**
	 * Returns true if the other cell is equivalent to this one in the sense of eqv?
	 */
	bool isEqv(const AnyCell *other) const;
	
	/**
	 * Returns true if the other cell is equal to this one in the sense of equal?
	 */
	bool isEqual(const AnyCell *other) const;

	void finalize();

protected:
	// Used for normal allocations
	// alloc::allocateCons already returns the correct garbage state
	AnyCell(CellTypeId typeId) : m_typeId(typeId)
	{
	}

	// Used for constant allocations
	AnyCell(CellTypeId typeId, GarbageState gcState) :
		m_typeId(typeId),
		m_gcState(gcState)
	{
	}
};

template <class T>
T* cell_cast(AnyCell *cellValue)
{
	if (T::isInstance(cellValue))
	{
		return static_cast<T*>(cellValue);
	}
	else
	{
		return nullptr;
	}
}

template <class T>
const T* cell_cast(const AnyCell *cellValue)
{
	if (T::isInstance(cellValue))
	{
		return static_cast<const T*>(cellValue);
	}
	else
	{
		return nullptr;
	}
}

template <class T>
T* cell_unchecked_cast(AnyCell *cellValue)
{
	// In debug builds make sure this is of the correct type
	assert(T::isInstance(cellValue));
	return static_cast<T*>(cellValue);
}

template <class T>
const T* cell_unchecked_cast(const AnyCell *cellValue)
{
	// In debug builds make sure this is of the correct type
	assert(T::isInstance(cellValue));
	return static_cast<T*>(cellValue);
}

template <>
inline AnyCell* cell_unchecked_cast<AnyCell>(AnyCell *cellValue)
{
	return cellValue;
}

template <>
inline const AnyCell* cell_unchecked_cast<AnyCell>(const AnyCell *cellValue)
{
	return cellValue;
}

}

#endif

